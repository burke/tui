# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `json` gem.
# Please instead update this file by running `bin/tapioca gem json`.

# typed: true

class Class < ::Module
  def json_creatable?; end
end

module JSON
  private

  def dump(obj, anIO = T.unsafe(nil), limit = T.unsafe(nil)); end
  def fast_generate(obj, opts = T.unsafe(nil)); end
  def fast_unparse(obj, opts = T.unsafe(nil)); end
  def generate(obj, opts = T.unsafe(nil)); end
  def load(source, proc = T.unsafe(nil), options = T.unsafe(nil)); end
  def load_file(filespec, opts = T.unsafe(nil)); end
  def load_file!(filespec, opts = T.unsafe(nil)); end
  def parse(source, opts = T.unsafe(nil)); end
  def parse!(source, opts = T.unsafe(nil)); end
  def pretty_generate(obj, opts = T.unsafe(nil)); end
  def pretty_unparse(obj, opts = T.unsafe(nil)); end
  def recurse_proc(result, &proc); end
  def restore(source, proc = T.unsafe(nil), options = T.unsafe(nil)); end
  def unparse(obj, opts = T.unsafe(nil)); end
  def utf8_to_json(string, escape_slash = T.unsafe(nil)); end
  def utf8_to_json_ascii(string, escape_slash = T.unsafe(nil)); end
  def valid_utf8?(string); end

  class << self
    def [](object, opts = T.unsafe(nil)); end
    def create_fast_state; end
    def create_id; end
    def create_id=(new_value); end
    def create_pretty_state; end
    def deep_const_get(path); end
    def dump(obj, anIO = T.unsafe(nil), limit = T.unsafe(nil)); end
    def dump_default_options; end
    def dump_default_options=(_arg0); end
    def fast_generate(obj, opts = T.unsafe(nil)); end
    def fast_unparse(obj, opts = T.unsafe(nil)); end
    def generate(obj, opts = T.unsafe(nil)); end
    def generator; end
    def generator=(generator); end
    def iconv(to, from, string); end
    def load(source, proc = T.unsafe(nil), options = T.unsafe(nil)); end
    def load_default_options; end
    def load_default_options=(_arg0); end
    def load_file(filespec, opts = T.unsafe(nil)); end
    def load_file!(filespec, opts = T.unsafe(nil)); end
    def parse(source, opts = T.unsafe(nil)); end
    def parse!(source, opts = T.unsafe(nil)); end
    def parser; end
    def parser=(parser); end
    def pretty_generate(obj, opts = T.unsafe(nil)); end
    def pretty_unparse(obj, opts = T.unsafe(nil)); end
    def recurse_proc(result, &proc); end
    def restore(source, proc = T.unsafe(nil), options = T.unsafe(nil)); end
    def state; end
    def state=(_arg0); end
    def unparse(obj, opts = T.unsafe(nil)); end
    def utf8_to_json(string, escape_slash = T.unsafe(nil)); end
    def utf8_to_json_ascii(string, escape_slash = T.unsafe(nil)); end
    def valid_utf8?(string); end
  end
end

JSON::CREATE_ID_TLS_KEY = T.let(T.unsafe(nil), String)
JSON::DEFAULT_CREATE_ID = T.let(T.unsafe(nil), String)
JSON::ESCAPE_SLASH_MAP = T.let(T.unsafe(nil), Hash)

class JSON::GenericObject < ::OpenStruct
  def as_json(*_arg0); end
  def to_hash; end
  def to_json(*a); end
  def |(other); end

  class << self
    def dump(obj, *args); end
    def from_hash(object); end
    def json_creatable=(_arg0); end
    def json_creatable?; end
    def json_create(data); end
    def load(source, proc = T.unsafe(nil), opts = T.unsafe(nil)); end
  end
end

class JSON::JSONError < ::StandardError
  class << self
    def wrap(exception); end
  end
end

JSON::MAP = T.let(T.unsafe(nil), Hash)
JSON::Parser = JSON::Pure::Parser
module JSON::Pure; end
module JSON::Pure::Generator; end
module JSON::Pure::Generator::GeneratorMethods; end

module JSON::Pure::Generator::GeneratorMethods::Array
  def to_json(state = T.unsafe(nil), *_arg1); end

  private

  def json_transform(state); end
end

module JSON::Pure::Generator::GeneratorMethods::FalseClass
  def to_json(*_arg0); end
end

module JSON::Pure::Generator::GeneratorMethods::Float
  def to_json(state = T.unsafe(nil), *_arg1); end
end

module JSON::Pure::Generator::GeneratorMethods::Hash
  def to_json(state = T.unsafe(nil), *_arg1); end

  private

  def json_shift(state); end
  def json_transform(state); end
end

module JSON::Pure::Generator::GeneratorMethods::Integer
  def to_json(*_arg0); end
end

module JSON::Pure::Generator::GeneratorMethods::NilClass
  def to_json(*_arg0); end
end

module JSON::Pure::Generator::GeneratorMethods::Object
  def to_json(*_arg0); end
end

module JSON::Pure::Generator::GeneratorMethods::String
  mixes_in_class_methods ::JSON::Pure::Generator::GeneratorMethods::String::Extend

  def to_json(state = T.unsafe(nil), *args); end
  def to_json_raw(*args); end
  def to_json_raw_object; end

  class << self
    def included(modul); end
  end
end

module JSON::Pure::Generator::GeneratorMethods::String::Extend
  def json_create(o); end
end

module JSON::Pure::Generator::GeneratorMethods::TrueClass
  def to_json(*_arg0); end
end

class JSON::Pure::Generator::State
  def initialize(opts = T.unsafe(nil)); end

  def [](name); end
  def []=(name, value); end
  def allow_nan?; end
  def array_nl; end
  def array_nl=(_arg0); end
  def ascii_only?; end
  def buffer_initial_length; end
  def buffer_initial_length=(length); end
  def check_circular?; end
  def check_max_nesting; end
  def configure(opts); end
  def depth; end
  def depth=(_arg0); end
  def escape_slash; end
  def escape_slash=(_arg0); end
  def escape_slash?; end
  def generate(obj); end
  def indent; end
  def indent=(_arg0); end
  def max_nesting; end
  def max_nesting=(_arg0); end
  def merge(opts); end
  def object_nl; end
  def object_nl=(_arg0); end
  def space; end
  def space=(_arg0); end
  def space_before; end
  def space_before=(_arg0); end
  def to_h; end
  def to_hash; end

  class << self
    def from_state(opts); end
  end
end

class JSON::Pure::Parser < ::StringScanner
  def initialize(source, opts = T.unsafe(nil)); end

  def parse; end
  def reset; end
  def source; end

  private

  def convert_encoding(source); end
  def parse_array; end
  def parse_object; end
  def parse_string; end
  def parse_value; end
end

JSON::Pure::Parser::ARRAY_CLOSE = T.let(T.unsafe(nil), Regexp)
JSON::Pure::Parser::ARRAY_OPEN = T.let(T.unsafe(nil), Regexp)
JSON::Pure::Parser::COLLECTION_DELIMITER = T.let(T.unsafe(nil), Regexp)
JSON::Pure::Parser::EMPTY_8BIT_STRING = T.let(T.unsafe(nil), String)
JSON::Pure::Parser::FALSE = T.let(T.unsafe(nil), Regexp)
JSON::Pure::Parser::FLOAT = T.let(T.unsafe(nil), Regexp)
JSON::Pure::Parser::IGNORE = T.let(T.unsafe(nil), Regexp)
JSON::Pure::Parser::INFINITY = T.let(T.unsafe(nil), Regexp)
JSON::Pure::Parser::INTEGER = T.let(T.unsafe(nil), Regexp)
JSON::Pure::Parser::MINUS_INFINITY = T.let(T.unsafe(nil), Regexp)
JSON::Pure::Parser::NAN = T.let(T.unsafe(nil), Regexp)
JSON::Pure::Parser::NULL = T.let(T.unsafe(nil), Regexp)
JSON::Pure::Parser::OBJECT_CLOSE = T.let(T.unsafe(nil), Regexp)
JSON::Pure::Parser::OBJECT_OPEN = T.let(T.unsafe(nil), Regexp)
JSON::Pure::Parser::PAIR_DELIMITER = T.let(T.unsafe(nil), Regexp)
JSON::Pure::Parser::STRING = T.let(T.unsafe(nil), Regexp)
JSON::Pure::Parser::STR_UMINUS = T.let(T.unsafe(nil), TrueClass)
JSON::Pure::Parser::TRUE = T.let(T.unsafe(nil), Regexp)
JSON::Pure::Parser::UNESCAPE_MAP = T.let(T.unsafe(nil), Hash)
JSON::Pure::Parser::UNPARSED = T.let(T.unsafe(nil), Object)
JSON::State = JSON::Pure::Generator::State
JSON::UnparserError = JSON::GeneratorError

module Kernel
  private

  def JSON(object, *args); end
  def j(*objs); end
  def jj(*objs); end
end

class Set
  include ::Enumerable
end

Set::InspectKey = T.let(T.unsafe(nil), Symbol)

class Symbol
  include ::Comparable
end
