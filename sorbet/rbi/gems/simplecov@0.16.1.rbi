# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `simplecov` gem.
# Please instead update this file by running `bin/tapioca gem simplecov`.

# typed: true

module SimpleCov
  extend ::SimpleCov::Configuration

  class << self
    def add_not_loaded_files(result); end
    def clear_result; end
    def exit_exception; end
    def exit_status_from_exception; end
    def filtered(files); end
    def grouped(files); end
    def load_adapter(name); end
    def load_profile(name); end
    def pid; end
    def pid=(_arg0); end
    def process_result(result, exit_status); end
    def result; end
    def result?; end
    def result_exit_status(result, covered_percent); end
    def run_exit_tasks!; end
    def running; end
    def running=(_arg0); end
    def set_exit_exception; end
    def start(profile = T.unsafe(nil), &block); end
    def usable?; end
    def write_last_run(covered_percent); end
  end
end

class SimpleCov::ArrayFilter < ::SimpleCov::Filter
  def initialize(filter_argument); end

  def matches?(source_files_list); end
end

class SimpleCov::BlockFilter < ::SimpleCov::Filter
  def matches?(source_file); end
end

module SimpleCov::CommandGuesser
  class << self
    def guess; end
    def original_run_command; end
    def original_run_command=(_arg0); end

    private

    def from_command_line_options; end
    def from_defined_constants; end
    def from_env; end
  end
end

module SimpleCov::Configuration
  def adapters; end
  def add_filter(filter_argument = T.unsafe(nil), &filter_proc); end
  def add_group(group_name, filter_argument = T.unsafe(nil), &filter_proc); end
  def at_exit(&block); end
  def command_name(name = T.unsafe(nil)); end
  def configure(&block); end
  def coverage_dir(dir = T.unsafe(nil)); end
  def coverage_path; end
  def filters; end
  def filters=(_arg0); end
  def formatter(formatter = T.unsafe(nil)); end
  def formatter=(_arg0); end
  def formatters; end
  def formatters=(formatters); end
  def groups; end
  def groups=(_arg0); end
  def maximum_coverage_drop(coverage_drop = T.unsafe(nil)); end
  def merge_timeout(seconds = T.unsafe(nil)); end
  def minimum_coverage(coverage = T.unsafe(nil)); end
  def minimum_coverage_by_file(coverage = T.unsafe(nil)); end
  def nocov_token(nocov_token = T.unsafe(nil)); end
  def profiles; end
  def project_name(new_name = T.unsafe(nil)); end
  def refuse_coverage_drop; end
  def root(root = T.unsafe(nil)); end
  def skip_token(nocov_token = T.unsafe(nil)); end
  def track_files(glob); end
  def tracked_files; end
  def use_merging(use = T.unsafe(nil)); end

  private

  def parse_filter(filter_argument = T.unsafe(nil), &filter_proc); end
end

module SimpleCov::ExitCodes; end
SimpleCov::ExitCodes::EXCEPTION = T.let(T.unsafe(nil), Integer)
SimpleCov::ExitCodes::MAXIMUM_COVERAGE_DROP = T.let(T.unsafe(nil), Integer)
SimpleCov::ExitCodes::MINIMUM_COVERAGE = T.let(T.unsafe(nil), Integer)
SimpleCov::ExitCodes::SUCCESS = T.let(T.unsafe(nil), Integer)

class SimpleCov::FileList < ::Array
  def covered_lines; end
  def covered_percent; end
  def covered_percentages; end
  def covered_strength; end
  def least_covered_file; end
  def lines_of_code; end
  def missed_lines; end
  def never_lines; end
  def skipped_lines; end
end

class SimpleCov::Filter
  def initialize(filter_argument); end

  def filter_argument; end
  def matches?(_); end
  def passes?(source_file); end

  class << self
    def build_filter(filter_argument); end
    def class_for_argument(filter_argument); end
  end
end

module SimpleCov::Formatter; end

class SimpleCov::Formatter::MultiFormatter
  class << self
    def [](*args); end
    def new(formatters = T.unsafe(nil)); end
  end
end

module SimpleCov::Formatter::MultiFormatter::InstanceMethods
  def format(result); end
end

class SimpleCov::Formatter::SimpleFormatter
  def format(result); end
end

module SimpleCov::LastRun
  class << self
    def last_run_path; end
    def read; end
    def write(json); end
  end
end

class SimpleCov::LinesClassifier
  def classify(lines); end

  class << self
    def no_cov_line; end
    def no_cov_line?(line); end
    def whitespace_line?(line); end
  end
end

SimpleCov::LinesClassifier::COMMENT_LINE = T.let(T.unsafe(nil), Regexp)
SimpleCov::LinesClassifier::RELEVANT = T.let(T.unsafe(nil), Integer)
SimpleCov::LinesClassifier::WHITESPACE_LINE = T.let(T.unsafe(nil), Regexp)
SimpleCov::LinesClassifier::WHITESPACE_OR_COMMENT_LINE = T.let(T.unsafe(nil), Regexp)

class SimpleCov::Profiles < ::Hash
  def define(name, &blk); end
  def load(name); end
end

module SimpleCov::RawCoverage
  private

  def merge_file_coverage(file1, file2); end
  def merge_line_coverage(count1, count2); end
  def merge_results(*results); end
  def merge_resultsets(result1, result2); end

  class << self
    def merge_file_coverage(file1, file2); end
    def merge_line_coverage(count1, count2); end
    def merge_results(*results); end
    def merge_resultsets(result1, result2); end
  end
end

class SimpleCov::RegexFilter < ::SimpleCov::Filter
  def matches?(source_file); end
end

class SimpleCov::Result
  extend ::Forwardable

  def initialize(original_result); end

  def command_name; end
  def command_name=(_arg0); end
  def covered_lines(*args, &block); end
  def covered_percent(*args, &block); end
  def covered_percentages(*args, &block); end
  def covered_strength(*args, &block); end
  def created_at; end
  def created_at=(_arg0); end
  def filenames; end
  def files; end
  def format!; end
  def groups; end
  def least_covered_file(*args, &block); end
  def missed_lines(*args, &block); end
  def original_result; end
  def source_files; end
  def to_hash; end
  def total_lines(*args, &block); end

  private

  def coverage; end
  def filter!; end

  class << self
    def from_hash(hash); end
  end
end

module SimpleCov::ResultMerger
  class << self
    def clear_resultset; end
    def merge_results(*results); end
    def merged_result; end
    def results; end
    def resultset; end
    def resultset_path; end
    def resultset_writelock; end
    def store_result(result); end
    def stored_data; end
    def synchronize_resultset; end
  end
end

class SimpleCov::SourceFile
  def initialize(filename, coverage); end

  def build_lines; end
  def coverage; end
  def coverage_exceeding_source_warn; end
  def covered_lines; end
  def covered_percent; end
  def covered_strength; end
  def filename; end
  def line(number); end
  def lines; end
  def lines_of_code; end
  def lines_strength; end
  def missed_lines; end
  def never_lines; end
  def no_lines?; end
  def process_skipped_lines(lines); end
  def project_filename; end
  def relevant_lines; end
  def skipped_lines; end
  def source; end
  def source_lines; end
  def src; end

  private

  def round_float(float, places); end
end

class SimpleCov::SourceFile::Line
  def initialize(src, line_number, coverage); end

  def coverage; end
  def covered?; end
  def line; end
  def line_number; end
  def missed?; end
  def never?; end
  def number; end
  def skipped; end
  def skipped!; end
  def skipped?; end
  def source; end
  def src; end
  def status; end
end

class SimpleCov::StringFilter < ::SimpleCov::Filter
  def matches?(source_file); end
end

SimpleCov::VERSION = T.let(T.unsafe(nil), String)
